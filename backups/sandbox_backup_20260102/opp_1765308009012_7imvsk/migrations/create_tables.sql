```sql
CREATE TABLE IF NOT EXISTS customer_queries (
  id SERIAL PRIMARY KEY,
  query TEXT NOT NULL,
  user_id INTEGER REFEREN0CES users(id), -- Assuming `users` table exists for the corresponding ID mapping
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (user_id, query)
);

CREATE TABLE IF NOT EXISTS bot_responses (
  id SERIAL PRIMARY KEY,
  customer_query_id INTEGER REFERENCES customer_queries(id), -- Foreign key reference to `customer_queries` table ID
  response TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CALCULATED NOW(),
  satisfaction_score INTEGER CHECK (satisfaction_score >=1 AND satisfaction_score <=5), -- Constraint for score range
  FOREIGN KEY(customer_query_id) REFERENCES customer_queries(id) ON DELETE CASCADE,
  UNIQUE(customer_query_id, response)
);

CREATE TABLE IF NOT EXISTS customer_satisfaction (
  id SERIAL PRIMARY KEY,
  interaction_id INTEGER REFERENCES `interactions`(id), -- Assuming an interactions table exists for this foreign key reference.
  satisfaction_score INTEGER CHECK (satisfaction_score >=1 AND satisfaction extraneous details:
- Customer ID in PostgreSQL is auto-incremented and should not be manually entered as it's generated by the system upon new entries, which ensures uniqueness for each record without redundancy. The `SERIAL` data type was used here to represent this behavior directly within SQL syntax; however, please note that some DBMS like PostgreSQL may use `BIGINT` or an auto-increment integer column instead of SERIAL in more recent versions (PostgreSQL 10 and later).
- The unique constraint on `(user_id, query)` ensures each user's interaction is recorded distinctly. This helps prevent duplicate queries from the same customer being logged twice under different IDs or timestamps within a single day/session. A composite primary key here would be beneficial to avoid redundancy and maintain referential integrity with foreign keys pointing back to `users`.
- The constraint on satisfaction scores ensures that only valid user feedback (1 through 5) is captured for each interaction, which can help in analyzing customer experiences accurately without the need for additional checks within application code. This also enforces data consistency directly at the database level and simplifies validation logic when inserting or updating records.
- The `ON DELETE CASCADE` constraint ensures that if a query is deleted from the `customer_queries` table, its related response will be removed as well in order to maintain referential integrity without manual cleanup tasks. This behavior helps keep our database normalized and prevents orphan records (bot responses with no associated queries).
- The use of timestamping ensures we can track when each interaction happened which is vital for auditing, analytics, and possibly billing purposes if different levels/plans are involved in the future revenue capture plan.
- I assume there's an `interactions` table that holds detailed logs about customer interactions with both live agents and AI responses (not explicitly mentioned but necessary to link user satisfaction scores). This would need its own creation script, likely similar to this: 
===FILE:migrations/create_customer_queries.sql===
```sql
CREATE TABLE IF NOT EXISTS bot_responses (
  id SERIAL PRIMARY KEY,
  customer_query_id INTEGER REFERENCES `customer_queries`(id) -- Foreign key to the queries table created above
);

### API Endpoints with Express.js routes: ###
===FILE:routes/api.js===
```javascript
const express = require('express');
const router = express.Router();
// ... additional setup and imports ...

router.post('/newquery', async (req, res) => {
  const queryText = req.body.text; // Assuming the request body contains a `text` field for customer queries
  
  try {
    await db.query('INSERT INTO public.customer_queries(query, user_id) VALUES($1, $2) RETURNING id', [queryText, getCurrentUserId()]); // Placeholder function to retrieve the current logged-in/registered user's ID (implementation depends on your auth mechanism).
    const queryId = db.one_or_none('SELECT LASTVAL();');
    
    res.status(201).json({message: 'Query received', customer_query_id: Number(queryId)});
  } catch (error) {
    consoles.log(`Error creating new query entry`, error);
    return next((new Error('Failed to create a new support ticket')), res.status(400).json({message: 'Could not process your request'}));
  }
});

router.get('/botresponse', async (req, res) => {
  const queryId = req.query.customer_query_id; // Assuming the ID is passed as a GET parameter in this case for simplicity and ease of testing/mocking interactions during development phase.
  
  try {
    const responseData = await db.result(`SELECT b.*, uc.satisfaction_score FROM customer_responses AS b
                                        INNER JOIN (SELECT * FROM public.customer_queries WHERE id=$1) AS uc ON b.id = uc.customer_query_id;`, [queryId]);
    res.json(responseData);
  } catch (error) {
    return next((new Error('Failed to retrieve bot response for the query')), res.status(404).json({message: 'Requested resource not found'}));
  }
});
```
Please note that error handling, validation logic and actual AI model integration are omitted from this snippet due to their complex nature but should be implemented as per your specific business requirements in the full code. Also bear in mind security measures such as input sanitization against SQL injection or malicious inputs which I didn't cover here for brevity.
===FILE:create_customer_queries.sql===
```sql
CREATE TABLE IF NOT EXISTS bot_responses (
  id SERIAL PRIMARY KEY, -- Auto-incremented ID to avoid manual entry and ensure uniqueness of responses per query.
  customer_query_id INTEGER REFERENCES `customer_queries`(id), -- Foreign key reference for linked queries; ensures referential integrity between bot's response & corresponding user request, with automatic cascading deletes to clean up related records if needed (i.e., when a customer query is deleted).
  content TEXT NOT NULL, -- The generated or provided AI-powered support message/response text goes here; assumes the model returns this value as part of its output process.
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, -- Automatically records when each response is logged to track performance and timeliness metrics effectively over time (important for billing models).
  FOREIGN KEY(customer_query_id) REFERENCES `customer_queries`(`id`) ON DELETE CASCADE -- Ensures that we don't have orphan records if a query is removed, maintaining database integrity. This constraint also simplifies deletion of associated responses when necessary by allowing cascading delete operations to occur automatically upon the removal of customer queries/questions from the `customer_queries` table (referential action 'CASCADE').
);